import os
import subprocess
import random
import streamlit as st
import cv2 as cv
import numpy as np
import pandas as pd

from myapp.DeepSegmentor.options.test_options import TestOptions

path = 'myapp/DeepSegmentor/datasets/DeepCrack/'
test_path = 'test_img/'

results_path = ['myapp/DeepSegmentor/results',
                'myapp/DeepSegmentor/results/deepcrack',
                'myapp/DeepSegmentor/results/deepcrack/test_latest',
                'myapp/DeepSegmentor/results/deepcrack/test_latest/images/']

max_pixels = 500  # width or height

command_inference = 'python3 test.py --dataroot myapp/DeepSegmentor/datasets/DeepCrack --name deepcrack --model deepcrack --dataset_mode deepcrack --batch_size 1 --num_classes 1 --norm batch --num_test 10000 --display_sides 1'
command_png2mp4 = 'ffmpeg -framerate 30 -i ' + \
    results_path[-1] + '%1d_fused.png -vcodec libx264 output.mp4'


def make_abs_path():
    """
    Handle folder myapp as library
    """
    os.path.abspath(os.getcwd())
    return True


def create_folders():
    """
    Create default folders is not exist.
    """
    # Where images are being stored
    if not os.path.isdir(path):
        os.mkdir(path+test_path)

    for tmp_path in results_path:
        # Where results inference appears
        if not os.path.isdir(tmp_path):
            os.mkdir(tmp_path)


def clean_temp():
    """
    Remove all files in specific paths
    """

    paths_to_remove = ['myapp/DeepSegmentor/datasets/DeepCrack/test_img/',
                       'myapp/DeepSegmentor/results/deepcrack/test_latest/images']

    try:
        for path in paths_to_remove:
            for f in os.listdir(path):
                os.remove(os.path.join(path, f))
    except Exception as e:
        print(e)

    mp4_to_remove = ['temporal.mp4',
                     'output.mp4']

    for f in mp4_to_remove:
        try:
            os.remove(f)
        except Exception as e:
            print(e)


def clean_other_files_from_results(path=results_path[-1]):
    """
    Removing all temporal files generated by DeepCrack
    Like _image _label_viz _side1..5
    """
    for f in os.listdir(path):
        if not 'fused' in f:
            print("Removing..."+path+f)
            os.remove(path+f)

    return True


def reduce_dims(width, height, scale_percent):
    """
    Reduce dimensions until fit in less of max_pixels
    """

    while width > max_pixels or height > max_pixels:
        st.text('Reescalando: Weight-{} Height-{}'.format(width, height))

        width = int(width * scale_percent / 100)
        height = int(height * scale_percent / 100)
        dim = (width, height)

    return dim


def resize_one_image(filename_path):
    """
    Resize one image with filepath
    """

    temp_img = cv.imread(filename_path)

    scale_percent = 80  # downscale percent
    width = int(temp_img.shape[1])
    height = int(temp_img.shape[0])

    # Resize image to reduce inference time and max virtual memory needed
    reduced_dim = reduce_dims(width, height, scale_percent)

    resized = cv.resize(temp_img, reduced_dim,
                        interpolation=cv.INTER_AREA)
    return resized, reduced_dim


def resize_all_images_from_path(path):
    """
    Resize all images given a path.
    """

    # Resize all images
    for f in os.listdir(path):
        st.text(str(path+f))
        resized, reduced_dim = resize_one_image(path+f)  # Resized
        cv.imwrite(path+f, resized)  # Saved

    return reduced_dim


def split_video_by_frame(video_path, input_drop_path):
    """
    This script will split video into frames with opencv
    """
    # Author: https://gist.github.com/keithweaver/70df4922fec74ea87405b83840b45d57

    cap = cv.VideoCapture(video_path)
    currentFrame = 0
    while(True):
        try:
            # Capture frame-by-frame
            ret, frame = cap.read()
            # Saves image of the current frame in jpg file
            name = input_drop_path + str(currentFrame) + '.jpg'
            print('Creating...' + name)

            cv.imwrite(name, frame)

            # To stop duplicate images
            currentFrame += 1
        except Exception as e:
            break
            print(e)

    # When everything done, release the capture
    try:
        cap.release()
        cv.destroyAllWindows()
    except Exception as e:
        print(e)

    return True


if __name__ == '__main__':

    make_abs_path()  # Handle folder as library
    clean_temp()  # Clean temporal files on each upload
    create_folders()  # Create paths for inputs and results

    # General description

    st.title("Crack detector")
    st.text("Parte de tesis2, esta red neuronal permite detectar \nfisuras en diferentes materiales que automatizan \nprocesos de las inspecciones.")

    st.text("Red neuronal: DeepCrack - Liu, 2019")
    st.text("AplicaciÃ³n web: Liz F., Milagros M.")

    # Upload file
    st.subheader("- Elige una imagen o video")
    uploaded_file = st.file_uploader("Elige una imagen compatible", type=[
        'png', 'jpg', 'bmp', 'jpeg', 'mp4'])

    if uploaded_file is not None:  # File > 0 bytes

        file_details = {"FileName": uploaded_file.name,
                        "FileType": uploaded_file.type,
                        "FileSize": uploaded_file.size}
        st.write(file_details)

        #######################
        # VIDEO UPLOADED FILE
        #######################
        if file_details['FileType'] == 'video/mp4':

            with open('temporal.mp4', 'wb') as f:
                f.write(uploaded_file.getbuffer())

            split_video_by_frame('temporal.mp4', path+test_path)

            random_filename = random.choice(os.listdir(path+test_path))

            st.image(path+test_path+random_filename, caption='Imagen al azar del video',
                     channels="BGR", use_column_width=True)

            # Applying neural network: DeepCrack - Liu, 2019
            st.subheader('Ejecutando red neuronal DeepCrack... ')

            # Resize all images
            reduced_dim = resize_all_images_from_path(path+test_path)

            # INFERENCE
            result = os.popen(command_inference).read()

            # For CPU NN Inference we need to be sure that no gpu is being used by
            # the general script
            st.text(result)
            st.text("GPUS:"+"(if null -> cpu) \n")

            # Clean other files
            clean_other_files_from_results()  # default on result path

            # JPG -> MP4
            result = os.popen(command_png2mp4).read()
            st.text(result)

            # Display video
            st.subheader("Video procesado")
            st.video('output.mp4')

        #######################
        # IMAGE UPLOADED FILE
        #######################
        elif (file_details['FileType'] == 'image/png' or
              file_details['FileType'] == 'image/jpg' or
              file_details['FileType'] == 'image/jpeg' or
              file_details['FileType'] == 'image/bmp'):

            file_bytes = np.asarray(
                bytearray(uploaded_file.read()), dtype=np.uint8)
            image = cv.imdecode(file_bytes, 1)
            cv.imwrite(path+test_path+uploaded_file.name, image)

            st.write("This is your uploaded image:")
            st.image(image, caption='La imagen que subiste',
                     channels="BGR", use_column_width=True)

            resized, reduced_dim = resize_one_image(
                path+test_path+uploaded_file.name)

            # Display rezized image
            st.subheader("Redimensionando imagen...")
            st.image(resized, caption='La imagen escalada para poder ser procesada en la red neuronal sin saturar',
                     channels="BGR", use_column_width=True)
            cv.imwrite(path+test_path+uploaded_file.name, resized)

            # Applying neural network: DeepCrack - Liu, 2019
            st.subheader('Ejecutando red neuronal DeepCrack... ')

            # INFERENCE
            result = os.popen(command_inference).read()

            # For CPU NN Inference we need to be sure that no gpu is being used by
            # the general script
            st.text("GPUS:"+result+"(if null -> cpu) \n")

            # Results
            st.subheader('Inferencia terminada: resultados')

            # Get result image and display
            # st.text("Abriendo {}".format(results_path[-1]+uploaded_file.name[:-4]+"_fused.png"))
            result_image = cv.imread(
                results_path[-1]+uploaded_file.name[:-4]+"_fused.png")
            st.image(result_image, caption='La imagen que subiste',
                     channels="BGR", use_column_width=True)
